/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package Console;

import java.io.File;
import java.io.IOException;
import java.util.Calendar;
import java.util.Random;
import java.util.Scanner;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import jxl.Cell;
import jxl.Sheet;
import jxl.Workbook;
import jxl.read.biff.BiffException;
import jxl.write.Label;
import jxl.write.Number;
import jxl.write.WritableSheet;
import jxl.write.WritableWorkbook;
import jxl.write.WriteException;
import org.apache.commons.lang3.StringUtils;

/**
 *
 * @author lehuu
 */
public class Main {
    static Scanner input = new Scanner(System.in);
    static String orderGroupFile1 = "All the points generated by P.xls";
    static String orderGroupFile2 = "All the points generated by Q.xls";
    static String allofPointsFile = "Points.xls";
    static String koblitzsMap = "Koblitzs Map.xls";
    static String myMap = "My Map.xls";
    static String convertmessage = "Message into a series of numbers.xls";
    
    static class Type {
        public String s;
        public int x;
        public Type(String s, int x) {
            this.s = s;
            this.x = x;
        }
    }
    
    static class StringPoint {
    public String s;
    public Point x;
    public int k; // number generated by Klobz Method
    public StringPoint(String s, Point x, int k) {
        this.s = s;
        this.x = x;
        this.k = k;
    }
    }
        
    static class Elliptic {
        public int a;
        public int b;
        public int p;
        public Elliptic(int a, int b, int p) {
            this.a = a;
            this.b = b;
            this.p = p;
        }
    }
    
    static class Point {
        public int x;
        public int y;
        public Point(int x, int y) {
           this.x = x;
           this.y = y;
        }
    }
    
    static class KeyPair {
        public Point PublicKey;
        public int PrivateKey;
        public KeyPair(Point Pub, int Priv) {
            this.PublicKey = Pub;
            this.PrivateKey = Priv;
        }
    }
    
    public static int rand(int min, int max) {
        try {
            Random rn = new Random();
            int range = max - min + 1;
            int randomNum = min + rn.nextInt(range);
            return randomNum;
        } catch (Exception e) {
            return -1;
        }
    }

    public static boolean isPrime(int n) {
        if (n == 2)
            return true;
        else if (n == 1)
            return false;
        for (int i = 2; i < n; i++) {
            if (n % i == 0) {
                return false;
            }
        }
        return true;
    }
    
    public static int mod(int p, int x) {
        x = x % p;
        if (x < 0) {
            x += p;
        }
        return x;
    }
    
    public static int inversioninFp(int p, int a) {
        if (a < 0) {
            a = p + (a % p);
        }
        int u = a, v = p, x1 = 1, x2 = 0;
        int q, r, x;
        while (u != 1) {
            q = v/u;
            r = v - q*u;
            x = x2 - q*x1;
            v = u;
            u = r;
            x2 = x1;
            x1 = x;
        }
        if (x1 < 0) {
            x1 = p + (x1 % p);
        }
        return x1;
    }
    
    public static boolean isPOSITIVE_INFINITY(Point P) {
        if (P.x == (int)Double.POSITIVE_INFINITY || P.y == (int)Double.POSITIVE_INFINITY) {
            return true;
        }
        return false;
    }
    
    public static boolean QisNEGATIVE_P(Point P, Point Q) {
        if ((P.x == Q.x) && (P.y == -Q.y)) {
            return true;
        }
        return false;
    }
    
    public static Point Pointaddition(Point P, Point Q, int p) {
        Point R = new Point((int)Double.POSITIVE_INFINITY, (int)Double.POSITIVE_INFINITY);
        int numerator, denominator;
        if (isPOSITIVE_INFINITY(Q)) {
            return P;
        } else if (isPOSITIVE_INFINITY(P)) {
            return Q;
        }
        if (QisNEGATIVE_P(P, Q)) {
            return R;
        }
        numerator = mod(p, Q.y - P.y);
        denominator = Q.x - P.x;
        if (denominator == 0) {
            return R;
        }
        denominator = inversioninFp(p, denominator);
        numerator = mod(p, numerator*denominator);
        R.x = mod(p, (int) Math.pow(numerator, 2));
        R.x = mod(p, R.x - P.x - Q.x);
        R.y = mod(p, numerator*mod(p, P.x - R.x));
        R.y = mod(p, R.y - P.y);
        return R;
    }
    
    public static Point Pointdoubling(Point P, Elliptic E) {
        Point R = new Point((int)Double.POSITIVE_INFINITY, (int)Double.POSITIVE_INFINITY);
        int numerator, denominator;
        numerator = mod(E.p, (int) (3*Math.pow(P.x, 2) + E.a));
        denominator = 2*P.y;
        if (denominator == 0) {
            return R;
        }
        denominator = inversioninFp(E.p, denominator);
        numerator = mod(E.p, numerator*denominator);
        R.x = mod(E.p, (int) Math.pow(numerator, 2));
        R.x = mod(E.p, R.x - mod(E.p, 2*P.x));
        R.y = mod(E.p, numerator*mod(E.p, P.x - R.x));
        R.y = mod(E.p, R.y - P.y);
        return R;
    }
    
    public static int allpointsEC_Fp(Elliptic E) { //EC_Fp is Elliptic Curve in Fp field
        WritableWorkbook workbook = null;
        WritableSheet sheet = null;
        int col = 0;
        int row = 0;
        int a = E.a;
        int b = E.b;
        int n = 0;
        int left_side[] = new int[E.p];
        int right_side[] = new int[E.p];
        for (int i = 0; i < E.p; i++) {
            left_side[i] = (i*i) % E.p;
            right_side[i] = (i*i*i + a*i + b) % E.p; 
        }
        try {
            workbook = Workbook.createWorkbook(new File(allofPointsFile));
            sheet = workbook.createSheet("AllofPoints", 0);
            sheet.addCell(new Label(col++, row, String.valueOf(Double.POSITIVE_INFINITY)));
            n++;
            for (int i = 0; i < E.p; i++) {
                for (int j = 0; j < E.p; j++) {
                    if (left_side[i] == right_side[j]) {
                        Point P = new Point(j,i);
                        String s = "(" + P.x + "," + P.y + ")";
                        if (col == 256) { //256 (IV) là số lượng tối đa của cột trong excel 
                            row++;
                            col = 0;
                        }
                        sheet.addCell(new Label(col++, row, s));
                        n++;
                    }
                }
            }
            workbook.write();
            workbook.close();
        } catch (IOException e) {
            System.out.println("Error create file\n" + e.toString());
        } catch (WriteException e) {
            System.out.println("File not found\n" + e.toString());
        }
        return n;
    }
    
    public static int orderGroup(Point P, Elliptic E, String filename) {
        WritableWorkbook workbook;
        WritableSheet sheet;
        int col = 0;
        int row = 0;
        int n = 0;
        String s;
        Point Q;
        try {
            workbook = Workbook.createWorkbook(new File(filename));
            sheet = workbook.createSheet("orderGroup", 0);
            sheet.addCell(new Label(col++, row, String.valueOf(Double.POSITIVE_INFINITY)));
            n++;
            s = "(" + P.x + "," + P.y + ")";
            sheet.addCell(new Label(col++, row, s));
            n++;
            Q = Pointdoubling(P, E);
            s = "(" + Q.x + "," + Q.y + ")";
            sheet.addCell(new Label(col++, row, s));
            n++;
            while (true) {
                Q = Pointaddition(P, Q, E.p);
                if (Q.x == (int) Double.POSITIVE_INFINITY || Q.y == (int) Double.POSITIVE_INFINITY) {
                    break;
                }
                s = "(" + Q.x + "," + Q.y + ")";
//                System.out.println(s);
                if (col == 256) { //256 (IV) là số lượng tối đa của cột trong excel 
                    row++;
                    col = 0;
                }
                sheet.addCell(new Label(col++, row, s));
                n++;
            }
            workbook.write();
            workbook.close();
        } catch (IOException e) {
            System.out.println("Error create file\n" + e.toString());
        } catch (WriteException e) {
            System.out.println("File not found\n" + e.toString());
        }
        return n;
    }
    
    public static Point computekP(String filename, int totalpointinfilename, int k) { //dành cho duyệt các
        String s;                                                                     //điểm có trong file
        Point Q = new Point((int) Double.POSITIVE_INFINITY, (int) Double.POSITIVE_INFINITY);
        Workbook workbook;
        try {
            workbook = Workbook.getWorkbook(new File(filename));
            Sheet sheet = workbook.getSheet(0);
            int rows = sheet.getRows() - 1;
            int row = 0;
            int col = k;
            if (k < totalpointinfilename) {
                k %= totalpointinfilename;
                if (k > 256) {
                    row = (k/256);
                    
                    if (row > rows) {
                        row %= rows;
                    }
                    col = k%256;
                }
            }
            Cell cell = sheet.getCell(col, row);
            s = cell.getContents();
            workbook.close();
            s = s.replaceAll("[^0-9]+", " ");
            String[] xy = s.trim().split(" ");
            Q.x = Integer.parseInt(xy[0]);
            Q.y = Integer.parseInt(xy[1]);
        } catch (BiffException | IOException e) {
            System.out.println("File not found\n" + e.toString());
        }
        return Q;
    }
    
    public static void koblitzMapGeneration(String filename) {
        WritableWorkbook workbook;
        WritableSheet sheet;
        String s = null;
        int character = 48; // 48 is char '0'
        try {
            workbook = Workbook.createWorkbook(new File(filename));
            sheet = workbook.createSheet("KoblitzMap", 0);
            for (int i = 0; i < 95; i++) {
                if (i < 10) {
                    s = Character.toString((char) character);
                    sheet.addCell(new Label(0, i, s));
                    sheet.addCell(new Number(1, i, i));
                    if (character == 57) { // 57 is char '9'
                        character = 65 - 1;    // 65 is char 'A'
                    }   // character = 65 - 1 because next instruction will return character 65
                    character++;
                } else if (i < 36) {
                    s = Character.toString((char) character);
                    sheet.addCell(new Label(0, i, s));
                    sheet.addCell(new Number(1, i, i));
                    if (character == 90) { // 90 is char 'Z'
                        character = 97 - 1;    // 97 is char 'a'
                    }   // character = 97 - 1 because next instruction will return character 97
                    character++;
                } else if (i < 62) {
                    s = Character.toString((char) character);
                    sheet.addCell(new Label(0, i, s));
                    sheet.addCell(new Number(1, i, i));
                    if (character == 122) { // 122 is char 'z'
                        character = 32 - 1;     // 32 is char 'Space'
                    }   // character = 32 - 1 because next instruction will return character 32
                    character++;
                } else if (i < 78) {
                    s = Character.toString((char) character);
                    sheet.addCell(new Label(0, i, s));
                    sheet.addCell(new Number(1, i, i));
                    if (character == 47) { // 47 is char '/'
                        character = 58 - 1;    // 58 is char ':'
                    }   // character = 58 - 1 because next instruction will return character 58
                    character++;
                } else if (i < 85) {
                    s = Character.toString((char) character);
                    sheet.addCell(new Label(0, i, s));
                    sheet.addCell(new Number(1, i, i));
                    if (character == 64) { // 64 is char '@'
                        character = 91 - 1;    // 91 is char '['
                    }   // character = 91 - 1 because next instruction will return character 91
                    character++;
                } else if (i < 91) {
                    s = Character.toString((char) character);
                    sheet.addCell(new Label(0, i, s));
                    sheet.addCell(new Number(1, i, i));
                    if (character == 96) { // 96 is char '`'
                        character = 123 - 1;    // 123 is char '{'
                    }   // character = 123 - 1 because next instruction will return character 123
                    character++;
                } else {
                    s = Character.toString((char) character++);
                    sheet.addCell(new Label(0, i, s));
                    sheet.addCell(new Number(1, i, i));
                }
            }
            workbook.write();
            workbook.close();
        } catch (IOException e) {
            System.out.println("Error create file\n" + e.toString());
        } catch (WriteException e) {
            System.out.println("File not found\n" + e.toString());
        }
    }
    
    public static void myMapGeneration(String filename) {
        WritableWorkbook workbook;
        WritableSheet sheet;
        String s;
        int character = 32; // 32 is char 'Space'
        try {
            workbook = Workbook.createWorkbook(new File(filename));
            sheet = workbook.createSheet("MyMap", 0);
            for (int i = 0; i < 95; i++) {
                s = Character.toString((char) character++);
                sheet.addCell(new Label(0, i, s));
                sheet.addCell(new Number(1, i, i));
            }
            workbook.write();
            workbook.close();
        } catch (IOException e) {
            System.out.println("Error create file\n" + e.toString());
        } catch (WriteException e) {
            System.out.println("File not found\n" + e.toString());
        }
    }
    
    public static KeyPair keypairGeneration(Elliptic E, Point P, int n, String filename) {
        int d;
        Point Q;
        KeyPair KP;
        do {
        //1. Select d belong [1, n-1]
            d = rand(1, n-1);
//            System.out.println("Private Key: " + d);
        //2. Compute Q = dP
            Q = computekP(filename, n, d);
//            System.out.println("Public Key: (" + Q.x + "," + Q.y + ")");
        } while (isPOSITIVE_INFINITY(Q));
        //3. Return(Q,d)
        KP = new KeyPair(Q, d);
        return KP;
    }
    
    public static String findcharinMap(String filenameMap, String cellContent, int col) {
        Workbook workbook;
        int rows;
        String result = null;
        try {
            workbook = Workbook.getWorkbook(new File(filenameMap));
            Sheet sheet = workbook.getSheet(0);
            rows = sheet.getRows();
            for (int r = 0; r < rows; r++) {
                if (sheet.getCell(col, r).getContents().equals(cellContent)) {
                    result = sheet.getCell((col+1)%2, r).getContents();
                    break;
                }
            }
            workbook.close();
        } catch (BiffException | IOException e) {
            System.err.println("File not found\n" + e.toString());
        }
        return result;
    }
    
    public static void convertmessageintoaseriesofnumbers(String filenameMap, String message) {
        WritableWorkbook write;
        WritableSheet sheet;
        int row = 0, col = 0, length = message.length();
        try {
            write = Workbook.createWorkbook(new File(convertmessage));
            sheet = write.createSheet("MessageConverted", 0);
            for (int i = 0; i < length; i++) {
                int chartonum = Integer.parseInt(findcharinMap(filenameMap, message.charAt(i) + "", 0));
                sheet.addCell(new Number(col++, row, chartonum));
                if (col == 256) {
                    row++;
                    col = 0;
                }
            }
            write.write();
            write.close();
        } catch (IOException | WriteException e) {
            System.err.println("File not found\n" + e.toString());
        }
    }
    
    public static Type KoblitzsMethodforEncodingPlaintext(Elliptic E, int n, String message) {
        //Step1: Pick an elliptic curve Ep(a,b).
        //Step 2: Let us say that E has n points on it.
        //Step 3: Let us say that our alphabet consists of the digits
        //0,1,2,3,4,5,6,7,8,9 and the letters A,B,C,. . . , X,Y,Z coded as 10,11,. . . , 35.
        koblitzMapGeneration(koblitzsMap);
        //Step 4: This converts our message into a series of numbers.
        convertmessageintoaseriesofnumbers(koblitzsMap, message);
        //Step 5: Now choose an auxiliary base parameter, for example k = 20. 
        //( both parties should agree upon this)
        int k = rand(10, (int) Math.sqrt(n));
//        System.err.println("K = " + k);
        //Step 6: For each number mk (say), take x=mk + i, i belong [1, k-1] and try to solve for y.
        Workbook read1, read2;
        Type output;
        String messageEncoded = "";
        boolean loop, repeat;
        int rows1, cols1;
        int rows2, cols2;
        int m, mk;
        try {
            read1 = Workbook.getWorkbook(new File(convertmessage));
            read2 = Workbook.getWorkbook(new File(allofPointsFile));
            Sheet sheet1 = read1.getSheet(0);
            Sheet sheet2 = read2.getSheet(0);
            rows1 = sheet1.getRows();
            cols1 = sheet1.getColumns();
            rows2 = sheet2.getRows();
            cols2 = sheet2.getColumns();
            for (int r1 = 0; r1 < rows1;) {
                repeat = true;
                for (int c1 = 0; c1 < cols1; c1++) {
                    loop = true;
                    String data = sheet1.getCell(c1, r1).getContents();
                    if (!data.equals("")){
                        m = Integer.parseInt(sheet1.getCell(c1, r1).getContents());
                        mk = m*k;
                        do {
                            mk++;
                            if (mk > E.p) {
                                k = rand(10, (int) Math.sqrt(n));
                                System.err.println("K = " + k);
                                repeat = false;
                                break;
                            }
                            String pattern = "\\(" + mk + ",(\\d+)\\)";
                            Pattern patt = Pattern.compile(pattern);
                            Matcher mat;
                            for (int r2 = 0; r2 < rows2; r2++) {
                                for (int c2 = 0; c2 < cols2; c2++) {
                                    mat = patt.matcher(sheet2.getCell(c2, r2).getContents());
                                    if (mat.find()) {
                                        messageEncoded += mat.group(0) + " ";
                                        loop = false;
                                        break;
                                    }
                                }
                                if (!loop) {
                                    break;
                                }
                            }

                        } while (loop);
                        if (!repeat) {
                            break;
                        }
                    }
                }
                r1++;
                if (!repeat) {
                    System.err.println("Re-initialize");
                    r1 = 0;
                }
            }
            read1.close();
            read2.close();
        } catch (BiffException | IOException e) {
            System.err.println("File not found\n" + e.toString());
        }
        output = new Type(messageEncoded, k);
        return output;
    }
    
    public static void KoblitzsMethodforDecodingPlaintext(int k, String mencoded) {
        String pattern = "\\((\\d+),\\d+\\)";
        Pattern r = Pattern.compile(pattern);
        String[] encr = mencoded.trim().split(" ");
        int n = encr.length;
        for (int i = 0; i < n; i++) {
            Matcher match = r.matcher(encr[i]);
            if (match.find()) {
                int m = (Integer.parseInt(match.group(1)) - 1)/k;
                System.out.print(findcharinMap(koblitzsMap, String.valueOf(m), 1));
            }
        }
    }
    
    public static StringPoint ElGamaECEncryption(Elliptic E, Point P, int n, Point PublicKey, String plaintext) {
        long begin = Calendar.getInstance().getTimeInMillis();
        //1.Represent the message m as a point M in E(Fp).
        Type encoded = KoblitzsMethodforEncodingPlaintext(E, E.p, plaintext);
        System.out.println(" 1.Represent the message m as a point M in E(Fp)");
        System.out.println("  " + encoded.s);
        //2.Select k ∈ R[1,n−1]. 
        int k = rand(1, n-1);
        System.out.println(" 2.Select k ∈ R[1,n−1]");
        System.out.println("  k = " + k);
        //3.Compute C1 = kP.
        orderGroup(P, E, orderGroupFile1);
        Point C1 = computekP(orderGroupFile1, n, k);
        System.out.println(" 3.Compute C1 = kP");
        System.out.println("  C1 = (" + C1.x + "," + C1.y + ")");
        //4.Compute C2 = M + kQ. 
        orderGroup(PublicKey, E, orderGroupFile2);
        Point kQ = computekP(orderGroupFile2, n, k);
        System.out.println(" 4.Compute C2 = M + kQ");
        System.out.println("  kQ = " + "(" + kQ.x + "," + kQ.y + ")");
        String[] mess = encoded.s.trim().split(" ");
        int lenM = mess.length;
        String result = "";
        String pattern = "\\((\\d+),(\\d+)\\)";
        Pattern r = Pattern.compile(pattern);
        for (int i = 0; i < lenM; i++) {
            Matcher match = r.matcher(mess[i]);
            if (match.find()) {
                int x = Integer.parseInt(match.group(1));
                int y = Integer.parseInt(match.group(2));
                Point M = new Point(x, y);
                Point C2 = Pointaddition(M, kQ, E.p);
                result += "(" + C2.x + "," + C2.y + ") ";
            }
        }
        System.out.println("  C2 = " + result);
        //5.Return (C1,C2).
        System.out.println(" 5.Return (C1,C2)");
        StringPoint SP = new StringPoint(result, C1, encoded.x);
        long end = Calendar.getInstance().getTimeInMillis();
        System.out.println("Encryption Time: " + (end - begin) + "ms");
        return SP;
    }
    
    public static void ElGamaECDecryption(Elliptic E, Point P, int PrivateKey, StringPoint SP) {
        long begin = Calendar.getInstance().getTimeInMillis();
        int n = orderGroup(SP.x, E, "dC1.xls");
        if (PrivateKey > n) {
            PrivateKey = PrivateKey % n;
        }
        int k = n - PrivateKey;
        Point dC1 = computekP("dC1.xls", n, k);
        String pattern = "\\((\\d+),(\\d+)\\)";
        Pattern r = Pattern.compile(pattern);
        String[] encrypted = SP.s.trim().split(" ");
        int len = encrypted.length;
        String decrypted = "";
        for (int i = 0; i < len; i++) {
            Matcher match = r.matcher(encrypted[i]);
            if (match.find()) {
                int x = Integer.parseInt(match.group(1));
                int y = Integer.parseInt(match.group(2));
                Point M = new Point(x, y);
                Point C2 = Pointaddition(M, dC1, E.p);
                decrypted += "(" + C2.x + "," + C2.y + ") ";
            }
        }
        KoblitzsMethodforDecodingPlaintext(SP.k, decrypted);
        long end = Calendar.getInstance().getTimeInMillis();
        System.out.println("\nDecryption Time: " + (end - begin) + "ms");
    }
    
    
    
//------------------------------------------------------------------------------
    
    
    
    
    public static void main(String[] args){
        String message = StringUtils.repeat("A", 50); /*<-- 50bytes*/
        
        Elliptic E = new Elliptic(9, 7, 2011);
        System.out.println("Using Koblitz's Method for Encoding Plaintext");
        
        System.out.println("y^2 = x^3 + " + E.a + "x + " + E.b + " in field F(" + E.p + ")");
        System.out.println("Number of points: " + allpointsEC_Fp(E));
        System.out.println();
        
        Point P = new Point(756,1012);
        int n = orderGroup(P, E, orderGroupFile1);
        System.out.println("Number of points generated from point P: " + n);
        
        /*Diffie Hellman using ECC*/
        System.out.println("1. Alice pick up key pair:");
        KeyPair Akp = keypairGeneration(E, P, n, orderGroupFile1);
        System.out.println("Private Key: " + Akp.PrivateKey);
        System.out.println("Public Key: " + "(" + Akp.PublicKey.x + "," + Akp.PublicKey.y + ")");
        
        System.out.println("\n2. Bob pick up key pair:");
        KeyPair Bkp = keypairGeneration(E, P, n, orderGroupFile1);
        System.out.println("Private Key: " + Bkp.PrivateKey);
        System.out.println("Public Key: " + "(" + Bkp.PublicKey.x + "," + Bkp.PublicKey.y + ")");
        
        /*Encryption*/
        System.out.println("\nAlice encrypt message: " + message);
        StringPoint encrypted = ElGamaECEncryption(E, P, n, Bkp.PublicKey, message);
        
        /*Decryption*/
        System.out.print("\nBob decrypt messages: ");
        ElGamaECDecryption(E, P, Bkp.PrivateKey, encrypted);
        
        
        
    }
}
